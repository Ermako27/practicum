В сегодняшнем уроке мы расскажем и покажем как все настроить для того, чтобы писать код для node.js приложения на TypeScript с использованием ECMAScript модулей.
Рассмотрим новые значения параметров в tsconfig.json и на примерах увидим как они влияют на итоговый код. Так же познакомимся с новыми расширениями файлов,
которые позволяет использовать TypeScript.


## Параметры tsconfig.json
В самом начале стоит сказать, что Node.js, начиная с 12 версии, может в рамках одного приложения одновременно работать как CommonJs, так и с ECMAScript модулями. Например, сам код приложения и используемые им
зависимости могут иметь разные системы модулей.

Далее вспомним, что TypeScript сам по себе не запускается ни в node.js ни даже в браузере, так как он является просто типизированной надстройкой над JavaScript.
TypeScript транспилируется в JavaScript при помощи инструмента под названием tsc. То какой именно код мы получим в результате транспиляции мы можем настраивать в файле
tsconfig.json, при выборе настроек необходимо исходить из того где именно, в какой среде будет запускаться полученный код, в нашем случае эта среда - node.js с поддержкой ECMAScript модулей.

Для корректной работы транспилированного кода в нужной нам среде разработчики TypeScript для параметров `module` и `moduleResolution` добавили новые значения `Node16` и `NodeNext`. 
Эти новые значения как раз и говорят транспилятору TypeScript генерировать код, в котором могут одновременно использоваться CommonJs и ECMAScript модули.
Каждое из значений можно поставить в каждый из двух параметров. Для справки сразу дадим ссылок, чтобы разобраться что такое `module` и `moduleResolution`.
Для `module`
1. [что такое module](https://www.typescriptlang.org/docs/handbook/modules.html)
2. [какие значения он может принимать](https://www.typescriptlang.org/tsconfig#module)
Для `moduleResolution`
1. [что такое moduleResolution](https://www.typescriptlang.org/docs/handbook/module-resolution.html#node)
2. [какие значения он может принимать](https://www.typescriptlang.org/tsconfig#moduleResolution)

Если коротко `module` определяет для какой модульной системы будет сгенерирован код, `moduleResolution` определяет с помощью каких правил транспилятор будет производить поиск файла в файловой системе. 
Дальше мы рассмотрим три маленьких проекта, на их примере мы увидим как будет работать сборка и запуск кода, транспиляция которого проходила с разными значениями параметров `module` и `moduleResolution`,
поймем почему нужно использовать именно `Node16` или `NodeNext`. В каждом из примеров поле `type` в package.json имеет значение `module`. 

### Примеры
... тут текст из README в папках на этом же уровне.

## Новые расширения
Поле `type` в package.json определяет модульную систему во всем проекте в целом, и вы можете использовать такие привычные расширения как `.ts` или `.js`, подразумевая, что код в таких файлах
соответствует именно указанной в `type` модульной системе. Однако бывает так, что код в некотором файле должен использовать отличную модульную систему от той, что указана в поле `type`. Для этого в Node.js есть расширения `.cjs`, если файл
является CommonJs модулем и `.mjs`, если файл является ECMAScript модулем. TypeScript здесь добавляет свои расширения  `.cts` и `.mts`, при транспиляции они превращаются в `.cjs` и `.mjs` соответственно

## Итоги
